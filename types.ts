import type { WebSocket } from 'ws'; // Only for backend, frontend won't have this directly

export enum Screen {
  MainMenu = 'MainMenu',
  CreateRoom = 'CreateRoom',
  // JoinRoom is now handled by a modal, not a dedicated screen
  Lobby = 'Lobby',
  GameTable = 'GameTable',
  Settings = 'Settings',
}

export enum TurnPhase {
  KickOpenDoor = 'KickOpenDoor',
  ResolveDoorCard = 'ResolveDoorCard',
  Combat = 'Combat', // Simplified for now
  LootTheRoom = 'LootTheRoom',
  LookingForTrouble = 'LookingForTrouble', // Placeholder
  Charity = 'Charity', // Placeholder
  TurnEnd = 'TurnEnd',
}

export interface Player {
  id: string; // WebSocket connection ID or a unique player ID generated by server
  name: string;
  avatarUrl: string;
  level: number;
  gear: number;
  equippedItems: Card[];
  cardsInHand: Card[];
  isHost?: boolean;
  ws?: WebSocket; // Server-side only
}

export interface RoomSettings {
  roomName: string;
  password?: string; // Password validation not implemented in this step
  maxPlayers: number;
  extraDecks: string[]; // Feature not fully implemented with backend
  startingLevel: number;
}

export interface ChatMessage {
  id: string;
  playerId: string;
  playerName: string;
  text: string;
  timestamp: Date;
  roomId?: string; // To route messages on the server
}

export enum CardType {
  Door = 'Door',
  Treasure = 'Treasure',
  Monster = 'Monster',
  Curse = 'Curse',
  Item = 'Item',
  Class = 'Class',
  Race = 'Race',
  OneShot = 'OneShot',
  MonsterEnhancer = 'MonsterEnhancer',
  SpecialDoor = 'SpecialDoor',
}

export interface Card {
  id: string;
  name: string;
  type: CardType;
  description: string;
  imageUrl?: string;
  value?: number;
  bonus?: number;
  level?: number; // Monster level
  treasures?: number; // Treasures monster gives
  badStuff?: string;
  effect?: (gameState: GameState, playerId: string) => GameState; // Effects would be server-side
}

// Simplified GameState for server management, details TBD by gameLogic.ts on backend
export interface GameState {
  roomId: string;
  players: Player[];
  currentPlayerId: string | null;
  doorDeck: Card[];
  treasureDeck: Card[];
  doorDiscard: Card[];
  treasureDiscard: Card[];
  turnPhase: TurnPhase;
  currentEncounterCard: Card | null;
  activeMonster: Card | null; // Monster being fought
  log: string[];
  isGameStarted: boolean;
}

// This represents a room on the server
export interface ActiveRoom {
  id: string;
  settings: RoomSettings;
  players: Player[]; // List of players in the room
  chatMessages: ChatMessage[];
  gameState: GameState | null; // Game state specific to this room
  hostId: string | null;
}

// --- WebSocket Message Types ---

// Messages sent from Client to Server
export enum ClientMessageType {
  CREATE_ROOM = 'CREATE_ROOM',
  JOIN_ROOM = 'JOIN_ROOM',
  SEND_CHAT_MESSAGE = 'SEND_CHAT_MESSAGE',
  START_GAME = 'START_GAME',
  PLAYER_ACTION = 'PLAYER_ACTION', // Generic for game actions
  // Specific game actions
  KICK_OPEN_DOOR = 'KICK_OPEN_DOOR',
  RESOLVE_DOOR_CARD = 'RESOLVE_DOOR_CARD',
  PLAY_CARD_FROM_HAND = 'PLAY_CARD_FROM_HAND',
  END_TURN = 'END_TURN',
  LOOT_ROOM = 'LOOT_ROOM',
}

export interface ClientMessage {
  type: ClientMessageType;
  payload?: any;
  roomId?: string; // For messages related to a specific room after joining
  playerId?: string; // For identifying the sender on the backend
}

export interface CreateRoomPayload extends RoomSettings {
  playerName: string;
}
export interface JoinRoomPayload {
  roomId: string;
  playerName: string;
}
export interface SendChatMessagePayload {
  text: string;
}
export interface PlayerActionPayload {
  actionType: string; // e.g., "KICK_DOOR", "PLAY_CARD"
  cardId?: string; // e.g., for playing a card
  targetId?: string; // e.g., target player or monster
  // specific resolution for a door card
  resolutionAction?: 'takeToHand' | 'applyCurse' | 'fightMonster' | 'playImmediately';
}


// Messages sent from Server to Client(s)
export enum ServerMessageType {
  ERROR = 'ERROR', // General error message
  ROOM_CREATED = 'ROOM_CREATED', // Sent to creator
  ROOM_JOINED = 'ROOM_JOINED', // Sent to joiner
  PLAYER_JOINED_ROOM = 'PLAYER_JOINED_ROOM', // Broadcast to room
  PLAYER_LEFT_ROOM = 'PLAYER_LEFT_ROOM', // Broadcast to room
  ROOM_UPDATE = 'ROOM_UPDATE', // General update for room (players, settings)
  CHAT_MESSAGE_BROADCAST = 'CHAT_MESSAGE_BROADCAST', // New chat message
  GAME_STARTED = 'GAME_STARTED', // Broadcast when game starts
  GAME_STATE_UPDATE = 'GAME_STATE_UPDATE', // Full or partial game state update
  NOTIFICATION = 'NOTIFICATION', // General notification for the client
}

export interface ServerMessage {
  type: ServerMessageType;
  payload: any;
}

export interface ErrorPayload {
  message: string;
  details?: any;
}
export interface RoomCreatedPayload {
  room: ActiveRoom;
  localPlayerId: string; // The ID assigned to the player who created the room
}
export interface RoomJoinedPayload {
  room: ActiveRoom;
  localPlayerId: string; // The ID assigned to the player who joined
}
export interface PlayerJoinedRoomPayload {
  player: Player;
  room: ActiveRoom; // Or just relevant parts like updated player list
}
export interface PlayerLeftRoomPayload {
  playerId: string;
  room: ActiveRoom; // Or just relevant parts
}
export interface RoomUpdatePayload {
  room: ActiveRoom; // Could be partial updates too
}
export interface ChatMessageBroadcastPayload extends ChatMessage {}

export interface GameStartedPayload {
  gameState: GameState;
  roomId: string;
}
export interface GameStateUpdatePayload {
  gameState: GameState;
  roomId: string;
}
export interface NotificationPayload {
    message: string;
    level?: 'info' | 'warning' | 'error'; // For styling on frontend
}
